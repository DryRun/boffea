/*****************************************************************************
* Project: RooFit                                                           *
*                                                                           *
* This code was autogenerated by RooClassFactory                            * 
*****************************************************************************/

#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"

#include "Riostream.h" 

#include "TripleGaussianPdf2.h" 
#include <math.h> 
#include "TMath.h" 

double TripleGaussian2(double x, double mean, double s1, double s2, double s3, double ccore, double ctail) {
  // Enforce s1 < s2 < s3... not sure if it works
  if (s1 > s2 || s2 > s3) {
    return 1.0;
  }
  return (1. - ctail) * (ccore * TMath::Gaus(x, mean, s1, kTRUE) + (1. - ccore) * TMath::Gaus(x, mean, s2, kTRUE))
   + ctail * TMath::Gaus(x, mean, s3, kTRUE);
};

ClassImp(TripleGaussianPdf2); 

TripleGaussianPdf2::TripleGaussianPdf2(const char *name, const char *title, 
                                      RooAbsReal& _x,
                                      RooAbsReal& _mean,
                                      RooAbsReal& _s1,
                                      RooAbsReal& _s2,
                                      RooAbsReal& _s3,
                                      RooAbsReal& _ccore,
                                      RooAbsReal& _ctail) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mean("mean","mean",this,_mean),
  s1("s1","s1",this,_s1),
  s2("s2","s2",this,_s2),
  s3("s3","s3",this,_s3),
  ccore("ccore","ccore",this,_ccore),
  ctail("ctail","ctail",this,_ctail) {} 


TripleGaussianPdf2::TripleGaussianPdf2(const TripleGaussianPdf2& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mean("mean",this,other.mean),
  s1("s1",this,other.s1),
  s2("s2",this,other.s2),
  s3("s3",this,other.s3),
  ccore("ccore",this,other.ccore),
  ctail("ctail",this,other.ctail) {} 



Double_t TripleGaussianPdf2::evaluate() const 
{ 
  return TripleGaussian2(x, mean, s1, s2, s3, ccore, ctail);
} 


//
//Int_t TripleGaussianPdf2::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
//{ 
//  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
//  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
//  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
//  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
//  // EXPRESSION MULTIPLE TIMES
//
//  if (matchArgs(allVars,analVars,x)) return 1 ; 
//  return 0 ; 
//} 
//
//
//
//Double_t TripleGaussianPdf2::analyticalIntegral(Int_t code, const char* rangeName) const  
//{ 
//  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
//  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
//  // BOUNDARIES FOR EACH OBSERVABLE x
//
//  assert(code==1);
//  if (s1 > s2 || s2 > s3) {
//    return 1.0 / (x.max() - x.min());
//  } else {
//    return 1.0;
//  }
//  // return (x.max(rangeName)-x.min(rangeName)) ; 
//  //return 1 ; 
//} 
