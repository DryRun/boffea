/*****************************************************************************
* Project: RooFit                                                           *
*                                                                           *
* This code was autogenerated by RooClassFactory                            * 
*****************************************************************************/

#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"

#include "Riostream.h" 

#include "TripleGaussianPdf.h" 
#include <math.h> 
#include "TMath.h" 

double TripleGaussian(double x, double mean, double s1, double s2, double s3, double aa, double bb) {
  // Enforce s1 < s2 < s3... not sure if it works
  if (s1 > s2 || s2 > s3) {
    return 1.0;
  }
  double c1 = aa * TMath::Max(aa, bb) / (aa + bb);
  double c2 = bb * TMath::Max(aa, bb) / (aa + bb);
  double c3 = 1. - c1 - c2;
  return c1 * TMath::Gaus(x, mean, s1, kTRUE) + c2 * TMath::Gaus(x, mean, s2, kTRUE) + c3 * TMath::Gaus(x, mean, s3, kTRUE);
};

ClassImp(TripleGaussianPdf); 

TripleGaussianPdf::TripleGaussianPdf(const char *name, const char *title, 
                                      RooAbsReal& _x,
                                      RooAbsReal& _mean,
                                      RooAbsReal& _s1,
                                      RooAbsReal& _s2,
                                      RooAbsReal& _s3,
                                      RooAbsReal& _aa,
                                      RooAbsReal& _bb) :
  RooAbsPdf(name,title), 
  x("x","x",this,_x),
  mean("mean","mean",this,_mean),
  s1("s1","s1",this,_s1),
  s2("s2","s2",this,_s2),
  s3("s3","s3",this,_s3),
  aa("aa","aa",this,_aa),
  bb("bb","bb",this,_bb) {} 


TripleGaussianPdf::TripleGaussianPdf(const TripleGaussianPdf& other, const char* name) :  
  RooAbsPdf(other,name), 
  x("x",this,other.x),
  mean("mean",this,other.mean),
  s1("s1",this,other.s1),
  s2("s2",this,other.s2),
  s3("s3",this,other.s3),
  aa("aa",this,other.aa),
  bb("bb",this,other.bb) {} 



Double_t TripleGaussianPdf::evaluate() const 
{ 
  return TripleGaussian(x, mean, s1, s2, s3, aa, bb);
} 


//
//Int_t TripleGaussianPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
//{ 
//  // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
//  // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
//  // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
//  // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
//  // EXPRESSION MULTIPLE TIMES
//
//  if (matchArgs(allVars,analVars,x)) return 1 ; 
//  return 0 ; 
//} 
//
//
//
//Double_t TripleGaussianPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
//{ 
//  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
//  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
//  // BOUNDARIES FOR EACH OBSERVABLE x
//
//  assert(code==1);
//  if (s1 > s2 || s2 > s3) {
//    return 1.0 / (x.max() - x.min());
//  } else {
//    return 1.0;
//  }
//  // return (x.max(rangeName)-x.min(rangeName)) ; 
//  //return 1 ; 
//} 
